<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>DaC.lib_N1 API documentation</title>
<meta name="description" content="Module with the functions to implement the DaC for the Anderson problem." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>DaC.lib_N1</code></h1>
</header>
<section id="section-intro">
<p>Module with the functions to implement the DaC for the Anderson problem.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Module with the functions to implement the DaC for the Anderson problem.
&#39;&#39;&#39;
import numpy as np

from scipy.linalg import eigh_tridiagonal



def energies_ED( potential, hopping ):
    &#39;&#39;&#39;
    Calculate the eigenvalues (energies) of the Anderson model (tridiagonal matrix), using the
    function ***eigh_tridiagonal()*** defined in scipy.\n
    * **potential**: Values in the diagonal (chemical potential or magnetic field).\n
    * **hopping**: Values of the off-diagonal (hopping). They might be site-dependent.\n
    It returns an array with the energies.
    &#39;&#39;&#39;
    E, V = eigh_tridiagonal(-potential, hopping)

    return E


def PR_ED( potential, hopping, time_interest ):
    &#39;&#39;&#39;
    Calculate the PR using ED, for the Anderson model (tridiagonal matrix).\n
    * **potential**: Values in the diagonal (chemical potential or magnetic field).\n
    * **hopping**: Values of the off-diagonal (hopping). They might be site-dependent
    (but note that at least one eigenstate will be fully delocalized).\n
    * **time_interest**: For which time calculate the time evolution.\n
    It returns a 2D numpy array. Each row represent a different initial state,
    each column a different value of time.
    &#39;&#39;&#39;
    E, V = eigh_tridiagonal(-potential, hopping)

    V = V.T

    PR_T_ED = np.zeros( (len(E), len(time_interest)) )

    for j in range(0, len(E)):
        PR_T_ED[j] = 1/np.sum ( np.abs( np.dot( (V[:, j ][:, np.newaxis] * V).T, np.exp( -np.outer(E, time_interest)*1j ) ) )**4, axis = 0 )

    return PR_T_ED




def compare_vec( v_old, E_old, v_new, E_new, M, last_old, last_new, tol_overlap, Delta_E ):
    &#39;&#39;&#39;
    Function to check which new eigenstates (v_new) have been already obtained (in v_old).
    &#39;&#39;&#39;


    dif_E = np.fabs(np.tensordot(E_old, np.ones(len(E_new)), axes = 0) - np.tensordot(np.ones(len(E_old)), E_new, axes = 0)) &lt; Delta_E

    sure_old = np.sum( dif_E, axis = 1) == 0
    sure_new = np.sum( dif_E, axis = 0) == 0

    dif_E = 0

    store_v_new = v_new[sure_new]
    store_E_new = E_new[sure_new]

    v_old_local = v_old[np.logical_not(sure_old)]
    v_new = v_new[np.logical_not(sure_new)]
    E_new = E_new[np.logical_not(sure_new)]

    real = np.sum( np.fabs( np.dot( v_new[ :, : last_old - (last_new - M) ], np.transpose( v_old_local[ :, -(last_old - (last_new - M) ): ] ) ) ) &gt; tol_overlap, axis = 1 ) == 0

    v_new = v_new[real]
    E_new = E_new[real]

    if(np.sum(sure_new) != 0):

        v_new = np.concatenate( (v_new, store_v_new), axis = 0 )
        E_new = np.concatenate( (E_new, store_E_new) )

    return v_new, E_new



def check_variance_N1 (x):
    &#39;&#39;&#39;
    Check the variance of the eigenstates of the subsystem.
    Since we consider only nearest-neighbor hoppings,
    it is basically the population at the edge of the subsystem.
    &#39;&#39;&#39;

    (J0, J1, v) = x
    vari = J0*J0*v[:, 0]*v[:, 0] + J1*J1*v[:, -1]*v[:, -1]

    return vari


def obtain_eigen_subsystem(first_site, last_site, h, J, cutoff_variance):
    &#39;&#39;&#39;
    Calculate the true eigenvalues (energies) and eigenstates of a system
    which are localized in the given subsystem.
    &#39;&#39;&#39;

    hred_r = h[ first_site:last_site ]
    J_r = J[ first_site+1:last_site ]
    E, V = eigh_tridiagonal(-hred_r, J_r)
    V = V.T
    J0 = J[ first_site ]
    J1 = J[ last_site ]
    vari = check_variance_N1 ( [J0, J1, V ] )
    which = vari &lt; cutoff_variance

    E_subsystem = E[which]
    v_subsystem = V[which]

    return E_subsystem, v_subsystem



def add_new_data_E_PR_Population_Number( popu, E, PR, number, first, last, E_new, v_new ):
    &#39;&#39;&#39;
    Bookeepping the obtained energies, PR, and population.
    &#39;&#39;&#39;

    popu[ first : last ] = popu[ first : last ] + np.sum( v_new**2, axis = 0 )
    E[ number : number + len(E_new)] = E_new
    PR[ number : number + len(E_new)] = 1/np.sum( v_new**4, axis = 1 )

    number = number + len(E_new)

    return popu, E, PR, number


def eliminate_repetitions(how_many, previous_eigen, previous_E, v_new, E_new,
                        M, previous_interval, last, cutoff_overlap, cutoff_E, i):

    &#39;&#39;&#39;
    Delete unneeded eigenstates (no overlap between the subsystem
    in which they are localized and the actual subsystem)
    &#39;&#39;&#39;

    previous = np.sum(how_many[:i])
    who = np.arange( previous, previous + how_many[i] )
    v_new, E_new = compare_vec( previous_eigen[who], previous_E[who], v_new,
            E_new, M, previous_interval[i], last, cutoff_overlap, cutoff_E )

    return v_new, E_new


def update_bookkepping(v_new, E_new, last, previous_eigen = [], previous_E = [], how_many = np.zeros(1, dtype = int), previous_interval = np.zeros(1, dtype = int) ):
    &#39;&#39;&#39;
    Bookeep the relevant eigenstates (how many, their eigenvalues and interval)
    &#39;&#39;&#39;
    if(len(previous_eigen) == 0):
        previous_eigen = v_new
    else:
        previous_eigen = np.concatenate( (previous_eigen, v_new), axis = 0)

    previous_E = np.concatenate( (previous_E, E_new) )
    how_many = np.concatenate( (how_many, [len(E_new)] ) )
    previous_interval = np.concatenate ( (previous_interval, [last]) )

    return previous_eigen, previous_E, how_many, previous_interval




def DaC_eigen_N1( parameters_system, parameters_technical):
    &#39;&#39;&#39;
    Main function to obtain localized eigenstates of the Anderson model.\n

    * **parameters_system**: Object of the class **System_Parameters_Anderson**,
    containing physical parameters to describe the system.\n
    * **parameters_technical**: Object of the class **Technical_Parameters_Eigen**,
    containing several cutoffs and parameters needed in the DaC algorithm.\n
    It returns the set of obtained energies, PR and population in each site
    (to check that no overpopulation or missing population)
    &#39;&#39;&#39;
    h = parameters_system.potential
    J = parameters_system.hopping_dist
    L = parameters_system.system
    M = parameters_technical.subsystem
    shift = parameters_technical.shift
    jump = int(shift*M)


    cutoff_variance = parameters_technical.cutoff_variance
    cutoff_overlap = parameters_technical.cutoff_overlap
    cutoff_E = parameters_technical.cutoff_E

    E_local = np.zeros( L )
    PR_local = np.zeros( L )
    popu_local = np.zeros( L )

    first = 0
    last = M

    E_old, v_old = obtain_eigen_subsystem(first, last, h, J, cutoff_variance)

    number = 0

    popu_local, E_local, PR_local, number = add_new_data_E_PR_Population_Number(
                    popu_local, E_local, PR_local, number, first, last, E_old, v_old)


    previous_eigen, previous_E, how_many, previous_interval = update_bookkepping( v_old, E_old, last)

    first = jump

    while ( first &lt;= L - M ):

        last = first + M

        E_new, v_new = obtain_eigen_subsystem(first, last, h, J, cutoff_variance)

        if( len(E_new) != 0 ):

            for i in range(0, len(previous_interval) ):
                v_new, E_new = eliminate_repetitions(how_many, previous_eigen,
                                    previous_E, v_new, E_new, M, previous_interval,
                                    last, cutoff_overlap, cutoff_E, i)

                if(len(E_new) == 0):
                    break

        popu_local, E_local, PR_local, number = add_new_data_E_PR_Population_Number(
                        popu_local, E_local, PR_local, number, first, last, E_new, v_new)


        if(first == L - M):
            break

        previous_eigen, previous_E, how_many, previous_interval = update_bookkepping(
                                v_new, E_new, last, previous_eigen, previous_E,
                                how_many, previous_interval )


        first = min( first + jump, L-M)

        #Eliminate previous eigenstates, if no overlap with next subsystem
        x = np.argmax( previous_interval &gt; first )

        previous_eigen = previous_eigen[np.sum(how_many[:x]) : ]
        previous_E = previous_E[np.sum(how_many[:x]) : ]

        previous_interval = previous_interval[x:]
        how_many = how_many[x:]


    return E_local[:number], PR_local[:number], popu_local









def dynamics_site_first(x):
    &#39;&#39;&#39;
    Calculate the time evolution of several initial states (localized in one site),
    for all the times of interest.
    &#39;&#39;&#39;
    (delta, h, Jxx, J0, J1, max_va, T, epsilon, error_propagation) = x

    l0 = len(h)

    error_ampl = epsilon/( error_propagation*l0 )

    E, V = eigh_tridiagonal(-h, np.zeros(len(h)-1) + Jxx)

    V = V.T

    vari = check_variance_N1 ( [J0, J1, V ] )

    which = vari &lt; max_va

    number = np.sum(which)

    new_v = V[which]
    new_E = E[which]

    which_complete = np.sum ( new_v[:, delta:]**2, axis = 0 ) &gt; (1 - error_ampl)**2

    if(which_complete[0]):

        if( np.sum(which_complete) != len(which_complete) ):
            how_many = np.arange(len(which_complete))[np.logical_not(which_complete)][0]

        else:
            how_many = np.sum(which_complete)

        PR_T = np.zeros( (how_many, len(T)) )

        for j in range(0, how_many):
            PR_T[j] = 1/np.sum ( np.abs( np.dot( (new_v[:, delta+j ][:, np.newaxis] * new_v).T, np.exp( -np.outer(new_E, T)*1j ) ) )**4, axis = 0 )


    else:
        PR_T = []
        how_many = 0

    return PR_T, how_many



def DaC_dyn_N1( parameters_system, time, parameters_technical ):
    &#39;&#39;&#39;
    Main function to calculate the dynamics in the Anderson model.\n
    Note that we only consider constant hopping
    (otherwise, delocalized states exists).\n
    * **parameters_system**: Object of the class **System_Parameters_Anderson**,
    containing physical parameters to describe the system.\n
    * **time**: Array with the times of interest.
    * **parameters_technical**: Object of the class **Technical_Parameters_Dyn**,
    containing several cutoffs and parameters needed in the DaC algorithm.\n
    It returns a 2D numpy array with the values of the PR for the different initial
    states (rows), at each time of interest (columns), together with the
    corresponding initial site .
    &#39;&#39;&#39;
    L = parameters_system.system
    h = parameters_system.potential
    Jxx = parameters_system.hopping_strength

    T = time

    M = parameters_technical.subsystem
    epsilon = parameters_technical.precision
    variance = parameters_technical.cutoff_variance
    min_jump = parameters_technical.min_jump
    error_propagation = parameters_technical.error_propagation

    l0 = int(M*0.5)

    PR = []
    real_site = []
    site_now = 0

    while( site_now &lt; L ):

        if( site_now &lt;= l0 ):
            h_local = h[ :2*l0 ]
            J0 = 0
            J1 = Jxx
            first_dyn = site_now

        elif( L - site_now &lt;= l0):
            h_local = h[ -2*l0 : ]
            J0 = Jxx
            J1 = 0
            first_dyn = 2*l0-(L - site_now)

        else:
            h_local = h[ site_now -l0 : site_now + l0 ]
            J0 = Jxx
            J1 = Jxx
            first_dyn = l0

        PR_local, how_many = dynamics_site_first([first_dyn, h_local, Jxx, J0, J1, variance, T, epsilon, error_propagation])

        if(how_many != 0):
            if(len(PR) == 0):
                PR = PR_local
                real_site = np.arange(how_many) + site_now

            else:
                PR = np.concatenate( (PR, PR_local) )
                real_site = np.concatenate( (real_site, np.arange(how_many) + site_now) )

        site_now = site_now + max(how_many, min_jump)

    real_site = real_site.astype(int)

    return PR, real_site</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="DaC.lib_N1.DaC_dyn_N1"><code class="name flex">
<span>def <span class="ident">DaC_dyn_N1</span></span>(<span>parameters_system, time, parameters_technical)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function to calculate the dynamics in the Anderson model.</p>
<p>Note that we only consider constant hopping
(otherwise, delocalized states exists).</p>
<ul>
<li>
<p><strong>parameters_system</strong>: Object of the class <strong>System_Parameters_Anderson</strong>,
containing physical parameters to describe the system.</p>
</li>
<li>
<p><strong>time</strong>: Array with the times of interest.</p>
</li>
<li><strong>parameters_technical</strong>: Object of the class <strong>Technical_Parameters_Dyn</strong>,
containing several cutoffs and parameters needed in the DaC algorithm.</li>
</ul>
<p>It returns a 2D numpy array with the values of the PR for the different initial
states (rows), at each time of interest (columns), together with the
corresponding initial site .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DaC_dyn_N1( parameters_system, time, parameters_technical ):
    &#39;&#39;&#39;
    Main function to calculate the dynamics in the Anderson model.\n
    Note that we only consider constant hopping
    (otherwise, delocalized states exists).\n
    * **parameters_system**: Object of the class **System_Parameters_Anderson**,
    containing physical parameters to describe the system.\n
    * **time**: Array with the times of interest.
    * **parameters_technical**: Object of the class **Technical_Parameters_Dyn**,
    containing several cutoffs and parameters needed in the DaC algorithm.\n
    It returns a 2D numpy array with the values of the PR for the different initial
    states (rows), at each time of interest (columns), together with the
    corresponding initial site .
    &#39;&#39;&#39;
    L = parameters_system.system
    h = parameters_system.potential
    Jxx = parameters_system.hopping_strength

    T = time

    M = parameters_technical.subsystem
    epsilon = parameters_technical.precision
    variance = parameters_technical.cutoff_variance
    min_jump = parameters_technical.min_jump
    error_propagation = parameters_technical.error_propagation

    l0 = int(M*0.5)

    PR = []
    real_site = []
    site_now = 0

    while( site_now &lt; L ):

        if( site_now &lt;= l0 ):
            h_local = h[ :2*l0 ]
            J0 = 0
            J1 = Jxx
            first_dyn = site_now

        elif( L - site_now &lt;= l0):
            h_local = h[ -2*l0 : ]
            J0 = Jxx
            J1 = 0
            first_dyn = 2*l0-(L - site_now)

        else:
            h_local = h[ site_now -l0 : site_now + l0 ]
            J0 = Jxx
            J1 = Jxx
            first_dyn = l0

        PR_local, how_many = dynamics_site_first([first_dyn, h_local, Jxx, J0, J1, variance, T, epsilon, error_propagation])

        if(how_many != 0):
            if(len(PR) == 0):
                PR = PR_local
                real_site = np.arange(how_many) + site_now

            else:
                PR = np.concatenate( (PR, PR_local) )
                real_site = np.concatenate( (real_site, np.arange(how_many) + site_now) )

        site_now = site_now + max(how_many, min_jump)

    real_site = real_site.astype(int)

    return PR, real_site</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.DaC_eigen_N1"><code class="name flex">
<span>def <span class="ident">DaC_eigen_N1</span></span>(<span>parameters_system, parameters_technical)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function to obtain localized eigenstates of the Anderson model.</p>
<ul>
<li>
<p><strong>parameters_system</strong>: Object of the class <strong>System_Parameters_Anderson</strong>,
containing physical parameters to describe the system.</p>
</li>
<li>
<p><strong>parameters_technical</strong>: Object of the class <strong>Technical_Parameters_Eigen</strong>,
containing several cutoffs and parameters needed in the DaC algorithm.</p>
</li>
</ul>
<p>It returns the set of obtained energies, PR and population in each site
(to check that no overpopulation or missing population)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DaC_eigen_N1( parameters_system, parameters_technical):
    &#39;&#39;&#39;
    Main function to obtain localized eigenstates of the Anderson model.\n

    * **parameters_system**: Object of the class **System_Parameters_Anderson**,
    containing physical parameters to describe the system.\n
    * **parameters_technical**: Object of the class **Technical_Parameters_Eigen**,
    containing several cutoffs and parameters needed in the DaC algorithm.\n
    It returns the set of obtained energies, PR and population in each site
    (to check that no overpopulation or missing population)
    &#39;&#39;&#39;
    h = parameters_system.potential
    J = parameters_system.hopping_dist
    L = parameters_system.system
    M = parameters_technical.subsystem
    shift = parameters_technical.shift
    jump = int(shift*M)


    cutoff_variance = parameters_technical.cutoff_variance
    cutoff_overlap = parameters_technical.cutoff_overlap
    cutoff_E = parameters_technical.cutoff_E

    E_local = np.zeros( L )
    PR_local = np.zeros( L )
    popu_local = np.zeros( L )

    first = 0
    last = M

    E_old, v_old = obtain_eigen_subsystem(first, last, h, J, cutoff_variance)

    number = 0

    popu_local, E_local, PR_local, number = add_new_data_E_PR_Population_Number(
                    popu_local, E_local, PR_local, number, first, last, E_old, v_old)


    previous_eigen, previous_E, how_many, previous_interval = update_bookkepping( v_old, E_old, last)

    first = jump

    while ( first &lt;= L - M ):

        last = first + M

        E_new, v_new = obtain_eigen_subsystem(first, last, h, J, cutoff_variance)

        if( len(E_new) != 0 ):

            for i in range(0, len(previous_interval) ):
                v_new, E_new = eliminate_repetitions(how_many, previous_eigen,
                                    previous_E, v_new, E_new, M, previous_interval,
                                    last, cutoff_overlap, cutoff_E, i)

                if(len(E_new) == 0):
                    break

        popu_local, E_local, PR_local, number = add_new_data_E_PR_Population_Number(
                        popu_local, E_local, PR_local, number, first, last, E_new, v_new)


        if(first == L - M):
            break

        previous_eigen, previous_E, how_many, previous_interval = update_bookkepping(
                                v_new, E_new, last, previous_eigen, previous_E,
                                how_many, previous_interval )


        first = min( first + jump, L-M)

        #Eliminate previous eigenstates, if no overlap with next subsystem
        x = np.argmax( previous_interval &gt; first )

        previous_eigen = previous_eigen[np.sum(how_many[:x]) : ]
        previous_E = previous_E[np.sum(how_many[:x]) : ]

        previous_interval = previous_interval[x:]
        how_many = how_many[x:]


    return E_local[:number], PR_local[:number], popu_local</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.PR_ED"><code class="name flex">
<span>def <span class="ident">PR_ED</span></span>(<span>potential, hopping, time_interest)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the PR using ED, for the Anderson model (tridiagonal matrix).</p>
<ul>
<li>
<p><strong>potential</strong>: Values in the diagonal (chemical potential or magnetic field).</p>
</li>
<li>
<p><strong>hopping</strong>: Values of the off-diagonal (hopping). They might be site-dependent
(but note that at least one eigenstate will be fully delocalized).</p>
</li>
<li>
<p><strong>time_interest</strong>: For which time calculate the time evolution.</p>
</li>
</ul>
<p>It returns a 2D numpy array. Each row represent a different initial state,
each column a different value of time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PR_ED( potential, hopping, time_interest ):
    &#39;&#39;&#39;
    Calculate the PR using ED, for the Anderson model (tridiagonal matrix).\n
    * **potential**: Values in the diagonal (chemical potential or magnetic field).\n
    * **hopping**: Values of the off-diagonal (hopping). They might be site-dependent
    (but note that at least one eigenstate will be fully delocalized).\n
    * **time_interest**: For which time calculate the time evolution.\n
    It returns a 2D numpy array. Each row represent a different initial state,
    each column a different value of time.
    &#39;&#39;&#39;
    E, V = eigh_tridiagonal(-potential, hopping)

    V = V.T

    PR_T_ED = np.zeros( (len(E), len(time_interest)) )

    for j in range(0, len(E)):
        PR_T_ED[j] = 1/np.sum ( np.abs( np.dot( (V[:, j ][:, np.newaxis] * V).T, np.exp( -np.outer(E, time_interest)*1j ) ) )**4, axis = 0 )

    return PR_T_ED</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.add_new_data_E_PR_Population_Number"><code class="name flex">
<span>def <span class="ident">add_new_data_E_PR_Population_Number</span></span>(<span>popu, E, PR, number, first, last, E_new, v_new)</span>
</code></dt>
<dd>
<div class="desc"><p>Bookeepping the obtained energies, PR, and population.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_new_data_E_PR_Population_Number( popu, E, PR, number, first, last, E_new, v_new ):
    &#39;&#39;&#39;
    Bookeepping the obtained energies, PR, and population.
    &#39;&#39;&#39;

    popu[ first : last ] = popu[ first : last ] + np.sum( v_new**2, axis = 0 )
    E[ number : number + len(E_new)] = E_new
    PR[ number : number + len(E_new)] = 1/np.sum( v_new**4, axis = 1 )

    number = number + len(E_new)

    return popu, E, PR, number</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.check_variance_N1"><code class="name flex">
<span>def <span class="ident">check_variance_N1</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Check the variance of the eigenstates of the subsystem.
Since we consider only nearest-neighbor hoppings,
it is basically the population at the edge of the subsystem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_variance_N1 (x):
    &#39;&#39;&#39;
    Check the variance of the eigenstates of the subsystem.
    Since we consider only nearest-neighbor hoppings,
    it is basically the population at the edge of the subsystem.
    &#39;&#39;&#39;

    (J0, J1, v) = x
    vari = J0*J0*v[:, 0]*v[:, 0] + J1*J1*v[:, -1]*v[:, -1]

    return vari</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.compare_vec"><code class="name flex">
<span>def <span class="ident">compare_vec</span></span>(<span>v_old, E_old, v_new, E_new, M, last_old, last_new, tol_overlap, Delta_E)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to check which new eigenstates (v_new) have been already obtained (in v_old).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_vec( v_old, E_old, v_new, E_new, M, last_old, last_new, tol_overlap, Delta_E ):
    &#39;&#39;&#39;
    Function to check which new eigenstates (v_new) have been already obtained (in v_old).
    &#39;&#39;&#39;


    dif_E = np.fabs(np.tensordot(E_old, np.ones(len(E_new)), axes = 0) - np.tensordot(np.ones(len(E_old)), E_new, axes = 0)) &lt; Delta_E

    sure_old = np.sum( dif_E, axis = 1) == 0
    sure_new = np.sum( dif_E, axis = 0) == 0

    dif_E = 0

    store_v_new = v_new[sure_new]
    store_E_new = E_new[sure_new]

    v_old_local = v_old[np.logical_not(sure_old)]
    v_new = v_new[np.logical_not(sure_new)]
    E_new = E_new[np.logical_not(sure_new)]

    real = np.sum( np.fabs( np.dot( v_new[ :, : last_old - (last_new - M) ], np.transpose( v_old_local[ :, -(last_old - (last_new - M) ): ] ) ) ) &gt; tol_overlap, axis = 1 ) == 0

    v_new = v_new[real]
    E_new = E_new[real]

    if(np.sum(sure_new) != 0):

        v_new = np.concatenate( (v_new, store_v_new), axis = 0 )
        E_new = np.concatenate( (E_new, store_E_new) )

    return v_new, E_new</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.dynamics_site_first"><code class="name flex">
<span>def <span class="ident">dynamics_site_first</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the time evolution of several initial states (localized in one site),
for all the times of interest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamics_site_first(x):
    &#39;&#39;&#39;
    Calculate the time evolution of several initial states (localized in one site),
    for all the times of interest.
    &#39;&#39;&#39;
    (delta, h, Jxx, J0, J1, max_va, T, epsilon, error_propagation) = x

    l0 = len(h)

    error_ampl = epsilon/( error_propagation*l0 )

    E, V = eigh_tridiagonal(-h, np.zeros(len(h)-1) + Jxx)

    V = V.T

    vari = check_variance_N1 ( [J0, J1, V ] )

    which = vari &lt; max_va

    number = np.sum(which)

    new_v = V[which]
    new_E = E[which]

    which_complete = np.sum ( new_v[:, delta:]**2, axis = 0 ) &gt; (1 - error_ampl)**2

    if(which_complete[0]):

        if( np.sum(which_complete) != len(which_complete) ):
            how_many = np.arange(len(which_complete))[np.logical_not(which_complete)][0]

        else:
            how_many = np.sum(which_complete)

        PR_T = np.zeros( (how_many, len(T)) )

        for j in range(0, how_many):
            PR_T[j] = 1/np.sum ( np.abs( np.dot( (new_v[:, delta+j ][:, np.newaxis] * new_v).T, np.exp( -np.outer(new_E, T)*1j ) ) )**4, axis = 0 )


    else:
        PR_T = []
        how_many = 0

    return PR_T, how_many</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.eliminate_repetitions"><code class="name flex">
<span>def <span class="ident">eliminate_repetitions</span></span>(<span>how_many, previous_eigen, previous_E, v_new, E_new, M, previous_interval, last, cutoff_overlap, cutoff_E, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete unneeded eigenstates (no overlap between the subsystem
in which they are localized and the actual subsystem)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eliminate_repetitions(how_many, previous_eigen, previous_E, v_new, E_new,
                        M, previous_interval, last, cutoff_overlap, cutoff_E, i):

    &#39;&#39;&#39;
    Delete unneeded eigenstates (no overlap between the subsystem
    in which they are localized and the actual subsystem)
    &#39;&#39;&#39;

    previous = np.sum(how_many[:i])
    who = np.arange( previous, previous + how_many[i] )
    v_new, E_new = compare_vec( previous_eigen[who], previous_E[who], v_new,
            E_new, M, previous_interval[i], last, cutoff_overlap, cutoff_E )

    return v_new, E_new</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.energies_ED"><code class="name flex">
<span>def <span class="ident">energies_ED</span></span>(<span>potential, hopping)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the eigenvalues (energies) of the Anderson model (tridiagonal matrix), using the
function <strong><em>eigh_tridiagonal()</em></strong> defined in scipy.</p>
<ul>
<li>
<p><strong>potential</strong>: Values in the diagonal (chemical potential or magnetic field).</p>
</li>
<li>
<p><strong>hopping</strong>: Values of the off-diagonal (hopping). They might be site-dependent.</p>
</li>
</ul>
<p>It returns an array with the energies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def energies_ED( potential, hopping ):
    &#39;&#39;&#39;
    Calculate the eigenvalues (energies) of the Anderson model (tridiagonal matrix), using the
    function ***eigh_tridiagonal()*** defined in scipy.\n
    * **potential**: Values in the diagonal (chemical potential or magnetic field).\n
    * **hopping**: Values of the off-diagonal (hopping). They might be site-dependent.\n
    It returns an array with the energies.
    &#39;&#39;&#39;
    E, V = eigh_tridiagonal(-potential, hopping)

    return E</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.obtain_eigen_subsystem"><code class="name flex">
<span>def <span class="ident">obtain_eigen_subsystem</span></span>(<span>first_site, last_site, h, J, cutoff_variance)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the true eigenvalues (energies) and eigenstates of a system
which are localized in the given subsystem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obtain_eigen_subsystem(first_site, last_site, h, J, cutoff_variance):
    &#39;&#39;&#39;
    Calculate the true eigenvalues (energies) and eigenstates of a system
    which are localized in the given subsystem.
    &#39;&#39;&#39;

    hred_r = h[ first_site:last_site ]
    J_r = J[ first_site+1:last_site ]
    E, V = eigh_tridiagonal(-hred_r, J_r)
    V = V.T
    J0 = J[ first_site ]
    J1 = J[ last_site ]
    vari = check_variance_N1 ( [J0, J1, V ] )
    which = vari &lt; cutoff_variance

    E_subsystem = E[which]
    v_subsystem = V[which]

    return E_subsystem, v_subsystem</code></pre>
</details>
</dd>
<dt id="DaC.lib_N1.update_bookkepping"><code class="name flex">
<span>def <span class="ident">update_bookkepping</span></span>(<span>v_new, E_new, last, previous_eigen=[], previous_E=[], how_many=array([0]), previous_interval=array([0]))</span>
</code></dt>
<dd>
<div class="desc"><p>Bookeep the relevant eigenstates (how many, their eigenvalues and interval)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_bookkepping(v_new, E_new, last, previous_eigen = [], previous_E = [], how_many = np.zeros(1, dtype = int), previous_interval = np.zeros(1, dtype = int) ):
    &#39;&#39;&#39;
    Bookeep the relevant eigenstates (how many, their eigenvalues and interval)
    &#39;&#39;&#39;
    if(len(previous_eigen) == 0):
        previous_eigen = v_new
    else:
        previous_eigen = np.concatenate( (previous_eigen, v_new), axis = 0)

    previous_E = np.concatenate( (previous_E, E_new) )
    how_many = np.concatenate( (how_many, [len(E_new)] ) )
    previous_interval = np.concatenate ( (previous_interval, [last]) )

    return previous_eigen, previous_E, how_many, previous_interval</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="DaC" href="index.html">DaC</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="DaC.lib_N1.DaC_dyn_N1" href="#DaC.lib_N1.DaC_dyn_N1">DaC_dyn_N1</a></code></li>
<li><code><a title="DaC.lib_N1.DaC_eigen_N1" href="#DaC.lib_N1.DaC_eigen_N1">DaC_eigen_N1</a></code></li>
<li><code><a title="DaC.lib_N1.PR_ED" href="#DaC.lib_N1.PR_ED">PR_ED</a></code></li>
<li><code><a title="DaC.lib_N1.add_new_data_E_PR_Population_Number" href="#DaC.lib_N1.add_new_data_E_PR_Population_Number">add_new_data_E_PR_Population_Number</a></code></li>
<li><code><a title="DaC.lib_N1.check_variance_N1" href="#DaC.lib_N1.check_variance_N1">check_variance_N1</a></code></li>
<li><code><a title="DaC.lib_N1.compare_vec" href="#DaC.lib_N1.compare_vec">compare_vec</a></code></li>
<li><code><a title="DaC.lib_N1.dynamics_site_first" href="#DaC.lib_N1.dynamics_site_first">dynamics_site_first</a></code></li>
<li><code><a title="DaC.lib_N1.eliminate_repetitions" href="#DaC.lib_N1.eliminate_repetitions">eliminate_repetitions</a></code></li>
<li><code><a title="DaC.lib_N1.energies_ED" href="#DaC.lib_N1.energies_ED">energies_ED</a></code></li>
<li><code><a title="DaC.lib_N1.obtain_eigen_subsystem" href="#DaC.lib_N1.obtain_eigen_subsystem">obtain_eigen_subsystem</a></code></li>
<li><code><a title="DaC.lib_N1.update_bookkepping" href="#DaC.lib_N1.update_bookkepping">update_bookkepping</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>